### Challenge 1

- 为了写出这个自动化的脚本，我也是煞费苦心了。

```python
e0 = [1, -150, 4389, -43000, 131100]
e1 = [1, -177, 9143, -228909, 3264597, -28298835, 152170893, -502513551, 974729862, -995312448, 396179424]
e2 = [1, -196, 12537, -397764, 7189071, -77789724, 506733203, -1941451916, 4165661988, -4501832400, 1841875200]
e3 = [1, -153, 5317, -77199, 510274, -1269840]
e4 = [1, -194, 11791, -352754, 6011644, -61295576, 370272864, -1222050816, 1696757760]
e5 = [1, -169, 7702, -153082, 1477573, -6672349, 11042724]
e6 = [1, -202, 12936, -406082, 7170059, -74124708, 439747164, -1365683328, 1701311040]
e7 = [1, -206, 13919, -467924, 8975099, -102829454, 699732361, -2673468816, 4956440220, -2888395200]

e = [e0,e1,e2,e3,e4,e5,e6,e7] # 系数数组

cnt = 0 #计数器，用来选择系数数组

x0,x1,x2,x3,x4,x5,x6,x7 = var('x0 x1 x2 x3 x4 x5 x6 x7',domain=ZZ) # 定义变量
X = [x0,x1,x2,x3,x4,x5,x6,x7]

E = [4,10,10,5,8,6,8,9] # 指数数组

F = []
for i in E: #枚举指数
    leq = e[cnt][0]*X[cnt]**(i-0)
    for j in range(1,i+1):
        leq += e[cnt][j]*X[cnt]**(i-j)
    leq
    F.append(leq==0)
    cnt +=1

flag = ""

for i in range(len(F)): #依次求解方程
    ans = solve([F[i]],X[i])
    flag +=  chr(ans[-1])
flag #'sonorous'

```

### Challenge 2

这一关让我学到一个点，sage 中似乎不可以 var(x y z a b c d e ) 这样声明变量，最后还是通过和挑战 1 一样的定义方式定义了变量。

- 很烦，不想整了

```python

x0,x1,x2,x3,x4,x5,x6,x7 = var('x0 x1 x2 x3 x4 x5 x6 x7',domain=ZZ)
X = [x0,x1,x2,x3,x4,x5,x6,x7]


solve([x0==x3+x2,x0==2*x6,x4==x5+x3,x3+x4==x1,x4==x4+x7,x4==x6+x2,x0+x3+x2==2*x0,x4+x5==x0+2*x6],(x0,x1,x2,x3,x4,x5,x6,x7))

```

### Challenge 5

看起来有五个未知数，系数矩阵已经给出来了，唯一的问题是右端的常数项是乱序的。

如果我们想求出这五个未知数，那么显然应该把具有正确的顺序的常数项依次替换掉系数矩阵的第一列、第二列...

由于常数项数组仅含有五个数，所以可能的常数项顺序为 $A_5^5=5!=120$ ，我们直接爆破就好了。

根据题目的意思，求出变量之后，要把变量全部乘起来，最后的结果就是明文了。

```python
r1 = [33,79,29,41,47]
r2 = [79,27,39,79,44]
r3 = [90,83,58,1,90]
r4 = [38,32,13,15,96]
r5 = [72,82,88,83,23]

P1 = matrix([r1,r2,r3,r4,r5]) # 系数矩阵

C = [73300, 167887, 243754, 254984, 458756]

import itertools
for i in itertools.permutations(C):
    i0 = i[0]
    i1 = i[1]
    i2 = i[2]
    i3 = i[3]
    i4 = i[4]
    tmp = matrix([[i0],[i1],[i2],[i3],[i4]])
    tmp
    try:
        P1.solve_right(tmp)
    except:
        print("error")
```

最后求出来很多非整数解，不过好在还是发现了一组整数解：

```python
[  61]
[   3]
[4073]
[1151]
[   7]

```

```
ans = 61 * 3 * 4073 * 1151 * 7  #6005357463
```

然后我谷歌了一下，找到了一个[解密网址](https://www.dcode.fr/leet-speak-1337)

得到明文：GOOSESTAGE

### Challenge 6

$k_m$ 可被写为一个置换矩阵和一个对角矩阵的乘积：
$k_m=P*D$

解密运算所得的 $d_m$ 实际上等于：
$d_m=P*D^{-1}$

> 以上操作是书上给的，我实际上并不明白这两步操作背后的原因

那么现在 $E(e(m),k_m)=k_m*e(m)=P*D*e(m)$

那么：

$D(E(e(m),k_m))=P*D*e(m)*P*D^{-1}$

所以上面的式子如何化成 $e(m)$ 呢？

- 想不明白。

看看能否解密挑战给的密文吧。

- 很烦躁，题目咋不吧 k_m 给我，这我没办法构造 d_m 呀。

看来一定是通过什么方法也可以得到 d_m 的，

首先这组密文的长度是 15，所以 $k_m$ 是 15行15列的。

$k_m$ 可以写成置换矩阵和对角矩阵的乘积，