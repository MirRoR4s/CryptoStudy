# Chapter 1 Related Work

## 1.1 基本技术

### 1.1.1 静态链接库

- 存储适用于所有平台的所有密码学库的所有版本要求的空间相对比较大，为了较小存储消耗，我们可以仅存储每个函数的哈希值，而非函数的内容。
- 在链接和加载时一些地址会被修改，当我们在比较两个函数的内容的时候，一定要识别出这些地址并跳过它们。
- 除了调用了不同的子函数之外，一些函数可能会非常相似。为了区分它们，我们一定要根据它们调用的子函数的特性来特性化相似的函数。

该解决方案在 IDA 中得到了大规模的实施。IDA附带了一个签名数据库，涵盖了最常用的库、编译器和平台。当一个函数被识别出来时，它就会被自动重命名。可以为初始数据库不覆盖的库或编译环境创建新的签名。

最后，静态链接库的识别并不仅限于识别密码学库。当我们开始对软件进行逆向分析时，静态链接库识别技术可能会是我们首先尝试的技术。静态链接库识别技术在大部分基本情况下是准确且高效的。但是为了得到积极的结果，我们需要拥有一个签名，该签名须涵盖由确切的编译器所编译的密码学库的确切版本。在 1.3 节给出了用于比较两个二进制代码块的一些更加灵活的技巧。

### 1.1.2 特定常量

对称加密算法通常包含特定的常量，这些常量的范围可以从由一些比特构成的简单值，扩展到由上千字节构成的查找表。因为不可能在不同的算法中发现这些常量，所以我们可以利用它们来识别加密代码。人们广泛地使用该技巧，并在一些公开地、可用地工具中实现了它。比如 Findcrypt2（IDA 插件），KANAL（PEiD 插件），或者是 H&C 探测器等等。并且 Findcrypt2 还具有可被集成到一个可交互式的反汇编器内的优势。但是我们不建议使用以上任何工具之一，如 [33] 所述，以上工具大都不完整，并且面向特定的体系结构或操作系统，接口的可用性也很差。我们还应注意到，当寻找加密常量时，我们没有必要进行反汇编甚至是解析可执行文件的格式。

我们知道，目前为止所有基于常量识别的工具都仅仅依赖于静态分析。然而我们应牢记的是，常量识别也可以通过动态分析来进行。动态分析对于打包好的程序以及动态计算的常量来说是特别有用的。我们开发了一个基于PIN [52]的概念证明，它使用一个二进制程序来监控其内存访问和检测动态计算的加密常量。

我们对一个简单的程序运行了我们的 POC，

在 7-Zip 中，AES 查找表是动态计算的。如我们所料，两个程序的静态搜索都未能发现查找表，但是我们的工具却可以检测到查找表。

常量识别是非常有效的第一步，但是其不足以完整地、准确地恢复加密原语和操作模式。我们以 AES 表实现作为目标来展示一下常量识别的局限性。给定一个二进制程序，假设上述所列的某个工具已经检测到了AES 的 S 盒，我们现在要做的事情就是确定 AES 加解密程序的具体位置。事实上，程序的多个部分都会访问 S 盒，比如 AES 的密钥调度（无论加密还是解密）或是 4 kilobytes 的查找表生成程序。此外，我们还没有确认参数。最后比较重要的一点是，检测到的算法也可能是其他使用了 AES S 盒 的密码原语，比如 MAC 函数，Fugue 哈希函数 或是 LEX 流密码。即使最后一点在实际当中不太可能，但这个例子远不只是理论上的。举个例子，对于 EasyLock 的常量搜索发现了 AES 的 S 盒，但是这个 S 盒是由两个不在加密或解密流程中的函数所调用的。

- EasyLock 是一个商业化产品，用于加密 USB flash drives 中的文件

- 显然这个时候常量识别发生了误报，不过论文提到 EasyLock 的确使用了 AES 来加解密文件。

## 1.2 加密参数检索

### 1.2.1 从运行程序中的明文提取

让我们考虑一个解密其输入，加密其输出的程序。









